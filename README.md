# Masters Thesis Scripts
Scripts Made During My Master's working with RAD-Seq Data

Files were tested using results from the [ipyrad](https://ipyrad.readthedocs.io/en/latest/) and [STACKS](https://catchenlab.life.illinois.edu/stacks/) pipelines

The bash scripts take results from ipyrad and STACKS to look at the amount of missing data in either the phylip or structure files.

Each file only takes 1 file as an input as shown below.

```bash
./count_fastq_reads.sh File.fastq.gz #takes gzip file, but can be modified to take uncompressed reads
```
This will print `File.fastq.gz has X sequences` with X being the number of sequences


The *Missing_data_Ipyrad_Structure.sh* script will create a tsv file and print its contents showing the amount of missing data. 
```bash
./Missing_data_Ipyrad_Structure.sh ipyrad_output.str
```
The tsv will resemble the table below.
| Sample_ID | Total_Count | Sites_Present | Missing_Count | Percent_Missing |
| --------- | ----------- | ------------- | ------------- | --------------- |
| Sample1   | 100         | 80            | 20            | 20%             |
| Sample2   | 100         | 82            | 18            | 18%             |
| Sample3   | 100         | 94            | 6             | 6%              |


The *Missing_data_Structure.sh* does the same thing as above, but is adapted to STACK's output.
```bash
./Missing_data_Structure.sh file.structure #deals with STACKS logo and assumes pop info column present
````
| Sample_ID | Total_Count | Sites_Present | Missing_Count | Percent_Missing |
| --------- | ----------- | ------------- | ------------- | --------------- |
| Sample1   | 100         | 80            | 20            | 20%             |
| Sample2   | 100         | 82            | 18            | 18%             |
| Sample3   | 100         | 94            | 6             | 6%              |


The input for *Missing_data_phylip.py* assumes the input is tab delimited and will create a tsv and print its contents following the layout below as an example with *N* being considered a missing genotype.
```bash
./Missing_data_phylip.sh file.phylip #deals with STACKS logo in file
```
| Sample_ID | Marker_Count | Sites_Present | Number_of_Ns | Percent_of_Ns |
| --------- | ------------ | ------------- | ------------ | ------------- |
| Sample1   | 100          | 80            | 20           | 20%           |
| Sample2   | 100          | 82            | 18           | 18%           |
| Sample3   | 100          | 94            | 6            | 6%            |


For the phylip file created by ipyrad
```bash
./Missing_data_phylip_ipyrad.sh file.phy #slightly different format than STACKS output
```
| Sample_ID | Marker_Count | Sites_Present | Number_of_Ns | Percent_of_Ns |
| --------- | ------------ | ------------- | ------------ | ------------- |
| Sample1   | 100          | 80            | 20           | 20%           |
| Sample2   | 100          | 82            | 18           | 18%           |
| Sample3   | 100          | 94            | 6            | 6%            |

These scripts are useful just to get a quick insight into the results generated by these two softwares.

***

The python scripts are used to explore some common formats in bioinformatics.

*FastaSeqLen2Histo.py* generates a histogram of the sequence lengths from a fasta file. It can be run simply by providing it
an input file

```python
python FastaSeqLen2Histo.py -i file.fasta
```
![alt text](Python_Scripts/Histogram1.png "Histogram1")

By default it will generate a grey bar graph. Additional parameters allow you to add some customization such as `-c` to change the *color*, `-t` for a *Histogram title*, `-x` to change the *label for the X-axis*, and `-y` to change the *label for the Y-axis*.

```python
python FastaSeqLen2Histo.py -i file.fasta -c red -t My New Title -x My Sequence Length Distribution -y My Frequency Counts
```
![alt text](Python_Scripts/Histogram2.png "Histogram2")

The *ipyrad_loci2fasta.py* script converts the *.loci* file generated from ipyrad to a fasta file.
```python
python ipyrad_loci2.fasta.py -i ipyrad_output.loci -o ipyrad_output.fasta #specify output name
```

The *Genepop2MafGraph.py* script calculates and plots the minor allele frequency ***within*** populations. The samples are divided by population depending on a *population map*, similar to the same format used in the [STACKS Software](https://catchenlab.life.illinois.edu/stacks/manual/#popmap). The calculations are then saved to a tsv.

```python
python Genepop2MafGraph.py -i genepop_file.txt -p population_map.txt
```
![alt text](Python_Scripts/Maf_Plot.png "MAF Plot Within Populations")

The table created will have the Population Names for row names and the allele frequency bins as column names. The bins start from 0-0.5, in intervals of 0.025
|             | 0.0 | 0.025 | 0.050 | 0.075 | 0.100 | 0.150 | 0.175 | 0.200 | 0.225 |
| ----------- | --- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| Population1 | 0   | 0     | 0     | 1990  | 0     | 2252  | 530   | 2177  | 448   |
| Population2 | 0   | 0     | 0     | 1792  | 0     | 2410  | 273   | 2412  | 262   |
| Population3 | 0   | 0     | 0     | 2043  | 0     | 2231  | 578   | 2160  | 475   |

The *Pairwise_Fst_Heatmap.py* script takes the same input files as the *Genepop2MafGraph.py* script, but produces a heatmap showing the average F<sub>st</sub> values between populations.


```python
python Pairwise_Fst_Heatmap.py -i genepop_file.txt -p population_map.txt
```
Due to the nature of how F<sub>st</sub>  values are calculated, it is possible to generate negative values, which are to be interpreted as 0.
![alt text](Python_Scripts/Average_Multilocus_Fst_Plot.png "Average Fst Values")
These values are also stored into a tsv file that with just 2 columns, with column 1 being the names of the populations compared separated by a `_` and the average F<sub>st</sub>  value.
|                         |        |
| ----------------------- | ------ |
| population2_population1 | 0.0029 |
| population3_population1 | 0.0012 |


The *Plot_Fis_Vals.py* script produces a bar graph showing the average F<sub>is</sub>  value for each population. This script also accepts the same population map and genepop file as the two scripts listed above.

```python
python Plot_Fis_Vals.py -i genepop_file.txt -p population_map.txt
```
![alt text](Python_Scripts/Fis_Stats.png "Fis Values")

In addition to the F<sub>is</sub> values, QIntra (Gene Diversity Between Individuals) and QInter (Gene Diversity Among Individuals Within Populations) values are also saved.
|                | population1 | population2 | population3 | population4 | population5 | population6 | population7 |
| -------------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| QIntra         | 0.2997      | 0.2859      | 0.2915      | 0.2911      | 0.2863      | 0.2937      | 0.2929      |
| QInter         | 0.2809      | 0.2873      | 0.2781      | 0.2818      | 0.2872      | 0.2836      | 0.2768      |
| F<sub>is</sub> | -0.0673     | 0.0049      | -0.048      | -0.0328     | 0.0031      | -0.0354     | -0.0581     |

The *Missing_data_phylip.py* and *Missing_data_Structure.py* calculate the amount of missing data in these types of files. Phylip files are standardized so this only needs one input
```python
python Missing_data_phylip.py -i file.phylip
```
Produces a table such as the one below.
| Sample  | Number of Sites | Sites Genotyped | Missing Sites | Percent Missing |
| ------- | --------------- | --------------- | ------------- | --------------- |
| Sample1 | 100             | 80              | 20            | 20%             |
| Sample2 | 100             | 82              | 18            | 18%             |
| Sample3 | 100             | 94              | 6             | 6%              |

Since structure files can vary in the amount of metadata contained within them, the *Missing_data_Structure.py* script requires to column number where the genotype information begins using the first column flag `-fc` flag. If marker labels are present, the optional header line flag (`-hl`) can be used to specify which line number this information is located on. `-mi` is the missing integer flag that is used to specify the value used for a missing genotype.
```python
python Missing_data_Structure.py -i file.structure -mi -9 -fc 3 -hl 1
```
The same table is produced as above.
| Sample  | Number of Sites | Sites Genotyped | Missing Sites | Percent Missing |
| ------- | --------------- | --------------- | ------------- | --------------- |
| Sample1 | 100             | 80              | 20            | 20%             |
| Sample2 | 100             | 82              | 18            | 18%             |
| Sample3 | 100             | 94              | 6             | 6%              |

Both of these files have an optional `-o` flag to specify an output if the user is wanting to save the tsv file.

The *Filter_blastx_hits.py* script is a custom python script that takes blastx results in tsv format (without a header) and contains 25 columns and filters it to the *"best"* hit. This is done in a few steps.
1. Filter out blasts hits with non-RefSeq Accession IDs
2. If any blast hits for a query sequence  **completely** removes the query sequence from the dataframe, return those blast hits
3. Remove blast hits with descriptions matching *hypothetical protein* and *uncharacterized protein*
4. Repeat Step 2
5. Return the blast hit with the lowest e-value for each query sequence
   
```python
python -i blastx_hits.tsv -o filtered_blastx_hits.tsv #specify output
```

The *Filter_Accessions_by_Counts.py* script takes a space delimited *Counts* file where the first column is the number of occurences (i.e. counts) and the second column is a specific Accession ID. The script takes a tsv file where a column titled **refseq_peptide_predicted** is used to help extract the same number of rows for a particular accession ID as specified by the *counts* file.

```python
python Filter_Accesssions_by_Counts.py -i Main_Accessions_Dataframe.tsv -c Counts.txt -o Filtered_Accessions_Dataframe.tsv #specify output
```

The *Filter_Full_GO_Datasets.py* script is a custom script that takes in a dataframe generated using [biomaRt](https://bioconductor.org/packages/release/bioc/html/biomaRt.html) that contains annotations of the same accession across multiple datasets, and filters to the point where each accession ID's annotation information is coming from only one dataset. The dataframe should be tab-delimited, and contain a column titled **refseq_peptide_predicted**, where the accession IDs are contained. A list of the RefSeq accession IDs is also required (one entry per line), and the a list of the datasets in the dataframe sorted by the datasets with the great to least annotations. This is recommended so that the filterationg process can begin with the dataset with the greatest amount of annotations.
```python
python Filter_Full_GO_Datasets.py -i biomaRt_results.tsv -dl sorted_dataset_list.txt -rl refSeq_accessions_list.txt -o filtered_biomaRt_results.tsv #specify output
```

The *Split_Multilocus_Nexus.py* was designed to split the multilocus nexus file generated from a ipyrad analysis into separate nexus files for each locus. Please note that this script assumes the nexus file is partioned in a 0-based index and not a 1-based index. Slight modifications can be made to the script to change the resulting files, such as keeping the missing character as *?* instead of *N*, or changing the format of the files' names (currently starting with *Locus_*). Currently, it only looks for the sequence sections indicated by the "charset = " found within the *nexus* file, which can also be easily modified. I highly recommend running this script in a directory where you plan on storing all of the files generated from your file, which depends on the number of loci in the nexus file. A single nexus file is the only input this script requires.
```python
python Split_Multilocus_Nexus.py -i MultiLocus.nex
```

The *Zero2OneBased_Nexus.py* script changes the 0-Based Index nexus file created by ipyrad into a 1-Based Indexed nexus file by adding 1 to each starting position within the *charset* positions. `Charset` paritions will also begin at 1 instead of 0. Must specify an output name for the new file
```python
python Zero2OneBased_Nexus.py -i Nexus_file.nex -o New_Nexus_file.nex
```

The *RatePartitionPlots2pdf.py* script takes a *rate* file generated using [IQ-TREE](http://www.iqtree.org/) that is broken up into seperate partitions, and plots a simple line plot for each partition and saves the output into a pdf. The average rate is shown at the top right corner for each figure. After going through all the partitions, one last plot is generated with all the rate values for each partition plotted together as if they were concatentated together. Optional `-o` and `-c` flags let you choose the name of the output and the color of the line plots.
```python
python RatePartitionPlots2pdf.py -i iq_tree_output.rate -o Output_name.pdf -c Red #default color is red
```
An example of a plot is shown below.
![alt text](Python_Scripts/Example_Rate_Plot.png "Rate Plot for Partition 1")

The *Nexus2Fasta.py* and *Fasta2Nexus.py* scripts use Biopython to convert between the two data formats. Both require you to specify an output name.
```python
python Nexus2Fasta.py -i input.nex -o Output.fasta #usuage
python Fasta2Nexus.py -i input.fasta -o Output.nex
```

The *Get_Concat_Seq_From_Bed.py* script parses a bed file and creates a concatenated sequence of the mapped regions using the reference genome in fasta format used for the creation of the bed file.
```python
python Get_Concat_Seq_From_Bed.py -r Reference_Genome.fasta -b Bedfile.bed -o Optional_Output_Name.txt
```

Similarily to the *Get_Concat_Seq_From_Bed.py*, the *GetPutativeOrthologsFromLoci.py* script subsets a reference genome in fasta format using another file with mapping coordinates. In this script, putative orthologs (i.e. regions where reads aligned) are extracted using the *.loci* created in ipyrad. A fasta file for these individual reads is then generated.
```python
python GetPutativeOrthologsFromLoci.py -i input.loci -r Reference_Genome.fasta -o Optional_Output_name.fasta
```


The *STACKS_SamplesFa2StackedLoci.py* script takes in the *populations.samples.fa* created in the populations program in the STACKS suite and creates a *.loci* file, similar to what ipyrad generates. Clusters are formed by the *Locus_#* in the sequence names. Currently, all differences (including heterozygous sites) are flagged as a difference and marked as a variation. Will add modifications in the future to accept a population map to flag population-specific sites instead of all variant positions between reads.
```python
python STACKS_SamplesFa2StackedLoci.py -i populations.samples.fa -o Optional_Output_Name.loci
```